#\_Redux: Writing a Counter Reducer with Tests (카운터 리듀서 작성 및 테스트)

테스트 코드 작성 개발 방식으로 카운터 애플리케이션을위한 리듀서를 작성하는 방법과 리듀서를 구현하는 방법을 배우게됩니다.

## Transcript

00:00 첫 번째 함수는 카운터 예제의 리듀서입니다. 리듀서는 직선과 행동을 인수로 받아들이고 다음 특성을 반환합니다. 구현으로 들어가기 전에 Michael Jackson의 Expect 라이브러리를 사용하여 특정 어설 션을 작성하려고합니다. 우리는 카운터의 직선이 0이고 증가 동작을 전달할 때 하나를 반환해야한다고 주장 할 것입니다. 마찬가지로이 직선이 하나이고 증가 할 때 두 개를 반환해야합니다.

00 : 33 우리는 감소가 작동하는 방식을 테스트하는 몇 가지 테스트를 추가 할 것입니다. 즉, 감소가 2에서 1로, 1에서 0으로 감소하고 테스트가 성공적인지 여부를 알리기 위해 로그를 추가 할 것입니다.

0시 48분는 이 테스트를 실행 한 경우 우리는 심지어 우리의 리듀서를 구현하기 시작하지 않았기 때문에, 그들은 실제로 실패 할 것입니다. 액션 유형을 확인하여 시작할 것입니다. 액션 유형이 증가하는 경우 곧장 +1을 반환하지만, 감소하면 곧은 마이너스 1을 반환 할 것입니다.

01:10 당신이 시험을 치르면 우리는 이것이 시험에 합격하는 데 충분하다는 것을 알게 될 것입니다. 그러나 카운터 리듀서의 현재 구현에는 여전히 몇 가지 결함이 있습니다. 예를 들어 이해할 수없는 작업을 보내면 응용 프로그램의 현재 상태를 반환해야한다고 생각합니다.

01:31 그러나 우리가 확인하면 우리는 현재 알려지지 않은 행동을 처리하지 않기 때문에이 테스트가 실패한 것을 볼 것입니다. 나는 현재의 직선을 반환하는 else 절을 ​​추가 할 것이다. 검사는 이제 끝납니다.

01:46 또 다른 문제는 리듀서가 일반적으로 응용 프로그램을 직접 제어하는 ​​반면 현재는 초기 직선을 지정하지 않는다는 것입니다. 카운터 예제의 경우에는 0이됩니다. Redux에서 사용하는 규칙은 리듀서가 직선 인수로 undefined를받는 경우 응용 프로그램의 초기 직선으로 간주하는 것을 반환해야한다는 것입니다. 이 경우 0이됩니다.

02:14 이제 약간의 개조가 있습니다. 이 스위치를 switch 문으로 대체하고이 조건을 ES6 기본 인수로 바꾸겠다. 또한 함수 선언을 화살표 함수로 바꾸려고합니다.이 함수는 ES6에서 더 명확한 의미를가집니다.

```js
const expect = require("expect");

const counter = (state = 0, action) => {
  switch (action.type) {
    case "INCREMENT":
      return state + 1;
    case "DECREMENT":
      return state - 1;
    default:
      return state;
  }
};

expect(counter(0, { type: "INCREMENT" })).toEqual(1);
expect(counter(0, { type: "DECREMENT" })).toEqual(-1);
expect(counter(1, { type: "TYPE_SOMETHINGELSE" })).toEqual(1);
expect(counter(undefined, {})).toEqual(0);

console.log("Pass Test");
```
