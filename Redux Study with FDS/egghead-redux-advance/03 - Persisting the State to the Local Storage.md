# Redux: Persisting the State to the Local Storage

우리는 store.subscribe ()를 사용하여 앱의 상태 중 일부를 localStorage에 효율적으로 유지하고 새로 고침 한 후에 복원하는 방법을 배웁니다.

# Transcript

00:00 브라우저 localStorage API를 사용하여 localStorage에서 응용 프로그램의 상태를 유지하고 싶습니다. load state라는 함수와 localStorage 브라우저 API를 사용할 localStorage AS를 호출 할 새 모델을 작성하려고합니다.

localStorage function능은 키에 의해 로컬 스토리지에 보이는 문자열을 검색하고 JSON parse를 시도 할 것이다. 사용자 프라이버시 모드가 localStorage의 사용을 허용하지 않으면 localStorage getItem에 대한 호출이 실패 할 수 있으므로이 코드를 try / catch에 랩핑하는 것이 중요합니다.

serialized 된 state가 아니면 SKI가 존재 함을 의미하므로 reducer가 상태를 초기화하도록 undefined로 반환합니다. 그러나 직렬화 된 상태 문자열이 존재하는 경우 JSON.parse를 사용하여 상태 개체로 변환 할 것입니다. 마지막으로 어떤 오류가 발생하더라도 저는 그것을 안전하게 재생하고 reducer가 응용 프로그램을 초기화 할 수 있도록 undefined로 반환 할 것입니다.

이제 상태를 로드하는 함수를 작성 했으므로 상태를 localStorage에 저장하는 함수를 작성할 수도 있습니다. 그것은 state를 인수로 받아 들일 것이며 그것은 정반대의 일을 할 것입니다.

첫번째 작업은 JSON.stringify를 사용하여 문자열로 serializes하는 것입니다. 이것은 상태가 serializable한 경우에만 작동하지만 Redux의 일반적인 권장 사항입니다. 상태는 serializable해야합니다. 이제 JSON.stringify 및 localStorage set items goal이 실패 할 수 있으므로 앱이 충돌하지 않도록 오류를 잡는 것이 중요합니다.

에러를 무시할 수도 있지만 어딘가에를 기록 할 수 있습니다. 이제 index.js에 방금 쓴 save state 함수를 가져옵니다. 저장소 상태가 변경 될 때마다 상태를 저장해야하므로 저장소 구독 메서드를 사용하여 모든 상태 변경시 호출 될 listener를 추가하고 저장소의 현재 상태를 저장 상태로 전달하고 있습니다.

나는 몇 가지 todos를 추가하고있다. 나는 todos 중 하나를 토글하고있어, 그리고 refresh. 응용 프로그램의 상태는 다시로드 할 때마다 유지되며 실제로는 visibilityFilter도 유지됩니다. 일반적으로 우리는 UI 상태가 아닌 데이터 만 유지하기 때문에 원하는 내용이 아닐 수 있습니다.

전체 state 객체를 전달하는 대신이 문제를 해결하기 위해 state 객체의 todos 객체만 전달합니다. 이렇게하면 깨끗한 localStorage로 시작하고 두 개의 todos를 추가 한 다음 그 중 하나를 토글하고 visibilityFilter를 변경합니다. 새로 고침 후에도 todo가 여전히 있지만 표시 여부 필터가 모두 재설정됩니다.

store가 생성되면 todo는 지속 된 상태에서 보존되지만 visibilityFilter를는 reducer에 의해 초기화됩니다. 그러나 현재 코드에는 버그가 있습니다. 기존 할 일에 새로운 할 일 목록을 추가하면 나타나지 않을 것이며 동일한 키, 즉 0 인 두 명의 children가 발생했다는 경고가 기록됩니다.

이것이 뜻하는 바는 할 일 목록을 구성 할 때 todos를 렌더링 할 때 todos ID를 키로 사용한다는 것입니다. ToDo ID는 ToDo 작업 작성자에서 지정되며 next todo ID라는 로컬 변수를 카운터로 사용합니다.

key는 고유해야합니다. 그러나 응용 프로그램이 두 x 째 실행될 경우, 다음 todo ID가 다시 0으로 초기화 되 추가 된 새 todo는 첫 x 째 실행처럼 ID가 0입니다.

이 같은 방지하려면 문제는 내가 nide UUID라는 NPM 모듈을 설치하겠습니다. 매우 작은 모듈이며 두 가지 기능을 내 보냅니다. 우리가 사용할 함수는 표준의 이름 인 V4라고합니다.

매번 고유 한 문자열 ID를 생성하고 카운터 대신이 ID를 사용합니다. 카운터 장식을 노드 -uuid에서 V4 가져 오기로 바꾸고 V4를 호출하여 작업 작성자에게 고유 한 ID를 생성합니다.

이제 깨끗한 localStorage로 앱을 다시 실행 해 봅시다. 나는 몇 가지 새로운 할일을 추가하고, 나는 그것들을 토글하고 있는데, 이것들은 애플 리케이션에 새로워졌다. visibilityFilter를는 변경할 수 있지만 데이터를 유지하기 만하기 때문에 지속성이 유지되지 않습니다.

마지막으로 새로운 할일을 추가하고 성공적으로 추가됩니다. 그것은 또한 새로 고침을 할 수 있고, 그걸로 무언가를하고, 새로 고침 할 수 있고, 다시 올바른 상태에 있습니다.

할 일이 하나 남았습니다. 우리는 현재 구독 청취자 내에서 저장 상태를 호출하고 있으므로 저장 상태가 변경 될 때마다 호출됩니다. 그러나 확장 stringify 조작을 사용하기 때문에 너무 자주 호출하지 않는 것이 좋습니다.

이 문제를 해결하기 위해 load dash라는 라이브러리에 throttle이라는 편리한 유틸리티가 포함될 것입니다. throttle이라는 호출에서 다시 콜백을 지정하면 내가 통과 한 내부 함수가 지정한 밀리 초 수보다 자주 호출되지는 않습니다.

05:43 이 store 정말로 빨리 감축되었다고하더라도, 우리는 단지 1 초에 한 번만 localStorage에 글을 남기는다고 보장합니다. 이제 lodash에서 throttle이라는에 대한 import 구문을 추가하고 Throttle이라는 파일에서 직접 가져온 것을 알고 있으므로 단일 기능 때문에 번들 전체로드 대시로 끝나지 않습니다.

앱에 localStorage 지속성을 어떻게 추가했는지 다시 한번 살펴 보겠습니다. 먼저로드 상태 및 저장 상태 함수를 사용하여 새 모듈을 만들었습니다. 로드 상태는 localStorage를 조사하고, 상태의 직렬화 된 문자열이 JSON으로 구문 분석하려고 시도합니다.

뭔가 잘못되면 앱이 충돌하지 않도록 undefined 상태로 되돌 립니다. 우리는 저장소를 생성하기위한 두 번째 인수로 load state의 반환 값을 사용하여 저장소에서 지정된 초기 상태를 무시합니다.

우리는 store state에 대한 변경 사항을 통지 받기를 원합니다. 우리는 1 초에 1 회 이상 호출되지 않도록 보장하기 위해 lodash에서 throttle 기능으로 가입자를 감쌌습니다.

06:58 우리는 visibilityFilter가 아닌 todos 만 유지하기를 원하므로 현재 상태의 todos를 포함하는 객체를 명시 적으로 구문 분석합니다. 대신 state를 저장하면 현재 상태를 JSON.stringify로 문자열로 serialize하고 항목을 설정하려고 시도하지만 실패한 경우이 오류를 무시하고 앱이 충돌하지 않도록합니다.

마지막으로 우리는 todos에 대한 ID 생성을 메모리 카운터에서 매번 고유 한 ID 문자열을 생성하는 node.uuid의 함수로 변경합니다.
